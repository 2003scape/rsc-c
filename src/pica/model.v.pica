; shader for game models and terrain

; uniforms
.fvec model[4], projection_view_model[4]

.fvec light_ambience

.bool cull_front

; constants
.constf base_const(0.0, 1.0, -1.0, -0.5)

.alias zeros base_const.xxxx
.alias ones base_const.yyyy

; -255
.constf invert_index(-255.0, -255.0, -255.0, -255.0)

; 1/256
.constf byte_reciprocal(0.003906, 0.003906, 0.003906, 0.003906)

; outputs
.out out_position position
.out out_colour color
.out out_texture_position texcoord0

; inputs
.in in_position v0
.in in_normal v1
.in in_lighting v2
.in in_front_colour v3
.in in_front_texture v4
.in in_back_colour v5
.in in_back_texture v6

.proc main
    ; r0.xyz = in_position.xyz, w = 1.0f
    mov r0.xyz, in_position
    mov r0.w, ones

    ; gl_Position = projection_view_model * vec4(position, 1.0);
    dp4 out_position.x, projection_view_model[0], r0
    dp4 out_position.y, projection_view_model[1], r0
    dp4 out_position.z, projection_view_model[2], r0
    dp4 out_position.w, projection_view_model[3], r0

    ; r1 = vertex_colour
    mov r1, ones

    ; r2 = gradient_index
    mov r2, light_ambience.xxxx

    ; r3 = intensity
    mov r3, in_lighting.yyyy

    ifu cull_front
        ; add intensity to gradient index
        add r2, r2, r3

        mov r1.rgb, in_back_colour.rgb
        mov out_texture_position, in_back_texture.xy
    .else
        ; add -intensity to gradient index
        mul r3, base_const.zzzz, r3
        add r2, r2, r3

        mov r1.rgb, in_front_colour.rgb
        mov out_texture_position, in_front_texture.xy
    .end

    ; gradient_index = 255 - gradient_index
    add r2, invert_index, r2
    mul r2, base_const.zzzz, r2

    ; gradient_index = gradient_index / 256
    mul r2, byte_reciprocal, r2
    mov r2.w, ones

    ; gradient_index = gradient_index * gradient_index
    mul r2, r2, r2
    mov r2.w, ones

    ; vertex_colour * gradient_index
    mul r1, r1, r2

    mov out_colour, r1

    end
.end
